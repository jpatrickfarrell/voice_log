{% extends "base.html" %}

{% block title %}Create Voice Post - Voice Log{% endblock %}

{% block head %}
<meta name="description" content="Create a new voice post on Voice Log. Upload audio, generate transcripts, and publish listenable blog posts.">
{% endblock %}

{% block content %}
<div class="create-post-page">
    <div class="page-header">
        <div>
            <h1>Create Voice Post</h1>
            <p class="subtitle">Upload your audio and transform it into a listenable blog post with transcripts and summaries.</p>
        </div>
    </div>

    <div class="create-form-container">
        <form method="POST" enctype="multipart/form-data" class="create-form" id="createPostForm">
            <!-- Basic Information Section -->
            <div class="form-section">
                <div class="section-header">
                    <h3><i class="bi bi-info-circle"></i> Basic Information</h3>
                    <p>Provide basic details about your voice post</p>
                </div>
                
                <div class="section-content">
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="title" class="form-label">
                                Title <span class="text-muted">(optional)</span>
                            </label>
                            <input type="text" 
                                   class="form-control" 
                                   id="title" 
                                   name="title" 
                                   placeholder="Leave blank to auto-generate from transcript"
                                   maxlength="100">
                            <div class="form-text">
                                If left blank, we'll generate a compelling title from your transcript
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="privacy_level" class="form-label">Privacy Level</label>
                            <select class="form-control" id="privacy_level" name="privacy_level" required>
                                <option value="public">Public - Anyone can find and listen</option>
                                <option value="unlisted">Unlisted - Only people with the link</option>
                                <option value="private">Private - Only you can access</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Audio Input Section -->
            <div class="form-section">
                <div class="section-header">
                    <h3><i class="bi bi-mic"></i> Audio Input</h3>
                    <p>Choose how to provide your audio content</p>
                </div>
                
                <div class="section-content">
                    <!-- Input Method Toggle -->
                    <div class="input-method-toggle">
                        <div class="toggle-buttons">
                            <button type="button" class="toggle-btn" data-method="record" id="recordToggle">
                                <i class="bi bi-mic"></i>
                                Record Audio
                            </button>
                            <button type="button" class="toggle-btn" data-method="upload" id="uploadToggle">
                                <i class="bi bi-cloud-upload"></i>
                                Upload File
                            </button>
                        </div>
                    </div>

                    <!-- Upload Method -->
                    <div class="input-method" id="uploadMethod">
                        <div class="upload-area" id="uploadArea">
                            <div class="upload-icon">
                                <i class="bi bi-cloud-upload"></i>
                            </div>
                            <div class="upload-text">
                                <h4>Drop your audio file here or click to browse</h4>
                                <p>Supports MP3, WAV, FLAC, M4A, AAC, OGG, WEBM up to 50MB</p>
                            </div>
                            <input type="file" 
                                   class="form-control d-none" 
                                   id="audio_file" 
                                   name="audio_file" 
                                   accept="audio/*">
                            <input type="hidden" id="recordings_data" name="recordings_data">
                            <div class="form-text">Upload a file or record multiple segments below</div>
                            <div class="invalid-feedback"></div>
                        </div>
                        
                        <div class="file-preview d-none" id="filePreview">
                            <!-- File preview will be inserted here -->
                        </div>
                    </div>

                    <!-- Record Method -->
                    <div class="input-method d-none" id="recordMethod">
                        <div class="record-container">
                            <div class="record-status" id="recordStatus">
                                <div class="status-indicator">
                                    <i class="bi bi-mic"></i>
                                    <span>Ready to record</span>
                                </div>
                                <div class="record-time" id="recordTime">00:00</div>
                            </div>
                            
                            <div class="volume-meter-container">
                                <div class="volume-meter" id="volumeMeter">
                                    <div class="volume-bar" id="volumeBar"></div>
                                </div>
                                <div class="volume-label">Volume Level</div>
                            </div>
                            
                            <div class="record-controls">
                                <button type="button" class="btn btn-primary btn-lg record-btn" id="recordBtn">
                                    <i class="bi bi-mic"></i>
                                    <span>Start Recording</span>
                                </button>
                                
                                <button type="button" class="btn btn-outline-secondary btn-lg stop-btn d-none" id="stopBtn">
                                    <i class="bi bi-stop-circle"></i>
                                    <span>Stop Recording</span>
                                </button>
                                
                                <button type="button" class="btn btn-outline-danger btn-sm clear-btn d-none" id="clearBtn">
                                    <i class="bi bi-trash"></i>
                                    <span>Clear Recording</span>
                                </button>
                            </div>
                            
                            <div class="recording-preview d-none" id="recordingPreview">
                                <div class="preview-header">
                                    <h5><i class="bi bi-music-note-beamed"></i> Current Recording</h5>
                                    <p>Your recording has been auto-saved as a segment</p>
                                </div>
                                <audio controls id="recordingAudio" class="w-100">
                                    Your browser does not support the audio element.
                                </audio>
                                <div class="recording-info">
                                    <span class="recording-duration" id="recordingDuration"></span>
                                    <span class="recording-size" id="recordingSize"></span>
                                </div>
                                <div class="recording-actions mt-3">
                                    <button type="button" class="btn btn-outline-secondary btn-sm" id="discardRecordingBtn">
                                        <i class="bi bi-x-circle"></i> Discard & Re-record
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Recordings Table -->
                            <div class="recordings-table mt-4" id="recordingsTable" style="display: none;">
                                                            <div class="table-header">
                                <h5><i class="bi bi-collection-play"></i> Recording Segments</h5>
                                <p>Your recording segments are automatically saved. Manage them before creating the final post</p>
                            </div>
                                <div class="table-responsive">
                                    <table class="table table-hover">
                                        <thead>
                                            <tr>
                                                <th>#</th>
                                                <th>Duration</th>
                                                <th>Size</th>
                                                <th>Preview</th>
                                                <th>Actions</th>
                                            </tr>
                                        </thead>
                                        <tbody id="recordingsTableBody">
                                            <!-- Recording segments will be inserted here -->
                                        </tbody>
                                    </table>
                                </div>
                                <div class="table-footer">
                                    <div class="total-info">
                                        <strong>Total Segments:</strong> <span id="totalSegments">0</span>
                                        <strong class="ms-3">Total Duration:</strong> <span id="totalDuration">00:00</span>
                                    </div>
                                    <div class="table-actions">
                                        <button type="button" class="btn btn-outline-danger btn-sm" id="clearAllRecordingsBtn">
                                            <i class="bi bi-trash"></i> Clear All
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Processing Options Section -->
            <div class="form-section">
                <div class="section-header">
                    <h3><i class="bi bi-cpu"></i> Processing Options</h3>
                    <p>Choose how to process your audio file</p>
                </div>
                
                <div class="section-content">
                    <div class="processing-options">
                        <div class="form-check">
                            <input class="form-check-input" 
                                   type="checkbox" 
                                   id="auto_process" 
                                   name="auto_process" 
                                   checked>
                            <label class="form-check-label" for="auto_process">
                                <strong>Auto-process audio</strong>
                                <div class="option-description">
                                    Automatically generate transcript, title, and summary using AI
                                </div>
                            </label>
                        </div>
                        
                        <div class="processing-info">
                            <div class="info-item">
                                <i class="bi bi-file-text"></i>
                                <span>Transcript generation using <span id="apiProvider">AI</span></span>
                            </div>
                            <div class="info-item">
                                <i class="bi bi-magic"></i>
                                <span>AI-powered title and summary creation</span>
                            </div>
                            <div class="info-item">
                                <i class="bi bi-clock"></i>
                                <span>Processing typically takes 1-2 minutes</span>
                            </div>
                        </div>
                        
                        <div class="alert alert-info">
                            <i class="bi bi-info-circle"></i>
                            <strong>Note:</strong> AI processing requires either an OpenAI API key or Google Gemini API key to be configured. 
                            You can also process posts manually after creation.
                        </div>
                    </div>
                </div>
            </div>

            <!-- Form Actions -->
            <div class="form-actions">
                <button type="button" class="btn btn-outline-secondary" onclick="history.back()">
                    <i class="bi bi-arrow-left"></i> Cancel
                </button>
                
                <button type="submit" class="btn btn-primary" id="submitBtn">
                    <i class="bi bi-plus-circle"></i> Create Post
                </button>
            </div>
        </form>
        

    </div>
</div>
{% endblock %}

{% block scripts %}
<style>
.create-post-page {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
}

.create-form-container {
    background: var(--bg-main);
    border: 1px solid var(--border-light);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-md);
    overflow: hidden;
}

.create-form {
    display: flex;
    flex-direction: column;
}

.form-section {
    border-bottom: 1px solid var(--border-light);
}

.form-section:last-child {
    border-bottom: none;
}

.section-header {
    background: var(--bg-secondary);
    padding: 1rem 1.5rem;
    border-bottom: 1px solid var(--border-light);
}

.section-header h3 {
    font-size: 1.125rem;
    font-weight: 600;
    margin-bottom: 0.25rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.section-header h3 i {
    color: var(--primary-main);
}

.section-header p {
    color: var(--text-secondary);
    margin: 0;
    font-size: 0.875rem;
}

.section-content {
    padding: 1rem 1.5rem;
}

.form-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
}

.form-group {
    display: flex;
    flex-direction: column;
}

.form-label {
    font-weight: 500;
    margin-bottom: 0.375rem;
    color: var(--text-primary);
    font-size: 0.9rem;
}

.form-control {
    background: var(--bg-secondary);
    border: 1px solid var(--border-light);
    border-radius: var(--radius-md);
    padding: 0.625rem;
    font-size: 0.875rem;
    transition: border-color 0.15s ease;
}

.form-control:focus {
    border-color: var(--primary-main);
    box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    outline: none;
}

.form-text {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: 0.25rem;
}

/* Upload Area */
.upload-area {
    border: 2px dashed var(--border-medium);
    border-radius: var(--radius-lg);
    padding: 2rem;
    text-align: center;
    background: var(--bg-secondary);
    transition: all 0.15s ease;
    cursor: pointer;
    position: relative;
}

/* Responsive Design */
@media (max-width: 1200px) {
    .create-post-page {
        max-width: 100%;
        padding: 0 0.5rem;
    }
}

@media (max-width: 768px) {
    .create-post-page {
        padding: 0 0.5rem;
    }
    
    .section-header {
        padding: 0.75rem 1rem;
    }
    
    .section-content {
        padding: 0.75rem 1rem;
    }
    
    .form-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
    }
    
    .upload-area {
        padding: 1.5rem;
    }
    
    .upload-icon {
        font-size: 2.5rem;
    }
    
    .upload-text h4 {
        font-size: 1rem;
    }
    
    .upload-text p {
        font-size: 0.8rem;
    }
    
    .record-container {
        padding: 1rem;
    }
    
    .record-controls {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .record-controls .btn {
        width: 100%;
    }
    
    .recordings-table {
        font-size: 0.85rem;
    }
    
    .table-responsive {
        overflow-x: auto;
    }
    
    .table th,
    .table td {
        padding: 0.5rem 0.25rem;
        font-size: 0.8rem;
    }
}

@media (max-width: 480px) {
    .create-post-page {
        padding: 0 0.25rem;
    }
    
    .section-header {
        padding: 0.5rem 0.75rem;
    }
    
    .section-content {
        padding: 0.5rem 0.75rem;
    }
    
    .upload-area {
        padding: 1rem;
    }
    
    .upload-icon {
        font-size: 2rem;
    }
    
    .form-control {
        padding: 0.5rem;
        font-size: 0.8rem;
    }
    
    .btn {
        padding: 0.5rem 0.75rem;
        font-size: 0.85rem;
    }
}

.upload-area:hover {
    border-color: var(--primary-main);
    background: rgba(139, 92, 246, 0.05);
}

.upload-area.dragover {
    border-color: var(--primary-main);
    background: rgba(139, 92, 246, 0.1);
    transform: scale(1.02);
}

.upload-icon {
    font-size: 3rem;
    color: var(--text-muted);
    margin-bottom: 1rem;
}

.upload-area:hover .upload-icon {
    color: var(--primary-main);
}

.upload-text h4 {
    font-size: 1.125rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    color: var(--text-primary);
}

.upload-text p {
    color: var(--text-muted);
    margin: 0;
    font-size: 0.875rem;
}

.file-preview {
    background: var(--bg-secondary);
    border: 1px solid var(--border-light);
    border-radius: var(--radius-md);
    padding: 1rem;
    margin-top: 1rem;
}

.file-info {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.file-info i {
    font-size: 2rem;
    color: var(--primary-main);
}

.file-details {
    flex: 1;
}

.file-name {
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 0.25rem;
}

.file-size {
    font-size: 0.875rem;
    color: var(--text-muted);
}

/* Processing Options */
.processing-options {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
}

.form-check {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
}

.form-check-input {
    margin: 0;
    margin-top: 0.25rem;
}

.form-check-label {
    flex: 1;
}

.option-description {
    font-size: 0.875rem;
    color: var(--text-secondary);
    margin-top: 0.25rem;
}

.processing-info {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    margin-left: 1.75rem;
}

.info-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    color: var(--text-secondary);
}

.info-item i {
    color: var(--primary-main);
    width: 16px;
}

/* Form Actions */
.form-actions {
    padding: 1.5rem;
    background: var(--bg-secondary);
    display: flex;
    justify-content: space-between;
    gap: 1rem;
}

.btn {
    min-width: 120px;
    position: relative;
}

.btn-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    white-space: nowrap;
}

/* Input Method Toggle */
.input-method-toggle {
    margin-bottom: 1.5rem;
}

.toggle-buttons {
    display: flex;
    gap: 0.5rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-light);
    border-radius: var(--radius-md);
    padding: 0.25rem;
}

.toggle-btn {
    flex: 1;
    padding: 0.75rem 1rem;
    border: none;
    background: transparent;
    border-radius: var(--radius-sm);
    color: var(--text-secondary);
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
}

.toggle-btn:hover {
    color: var(--text-primary);
    background: rgba(139, 92, 246, 0.1);
}

.toggle-btn.active {
    background: var(--primary-main);
    color: white;
    box-shadow: 0 2px 4px rgba(139, 92, 246, 0.2);
}

.toggle-btn i {
    font-size: 1.125rem;
}

/* Input Methods */
.input-method {
    transition: all 0.3s ease;
}

.input-method.d-none {
    display: none !important;
}

/* Record Method */
.record-container {
    text-align: center;
    padding: 2rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-light);
    border-radius: var(--radius-lg);
}

.record-status {
    margin-bottom: 2rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: var(--bg-main);
    padding: 1rem 1.5rem;
    border-radius: var(--radius-md);
    border: 1px solid var(--border-light);
}

.status-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: var(--text-primary);
    font-weight: 500;
}

.status-indicator.recording {
    color: #EF4444;
}

.status-indicator.recording i {
    animation: pulse 1s infinite;
}

.record-time {
    font-family: 'Courier New', monospace;
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--text-primary);
}

/* Volume Meter */
.volume-meter-container {
    margin-bottom: 2rem;
    text-align: center;
}

.volume-meter {
    width: 100%;
    height: 60px;
    background: var(--bg-main);
    border: 1px solid var(--border-light);
    border-radius: var(--radius-md);
    overflow: hidden;
    position: relative;
    margin-bottom: 0.5rem;
}

.volume-bar {
    height: 100%;
    background: linear-gradient(90deg, #10B981, #3B82F6, #8B5CF6, #EF4444);
    width: 0%;
    transition: width 0.1s ease;
    border-radius: var(--radius-md);
}

.volume-label {
    font-size: 0.875rem;
    color: var(--text-secondary);
    font-weight: 500;
}

/* Record Controls */
.record-controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
}

.record-btn, .stop-btn {
    width: 200px;
    height: 60px;
    border-radius: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    font-weight: 600;
    font-size: 1.125rem;
}

.record-btn {
    background: var(--primary-main);
    border: none;
    color: white;
}

.record-btn:hover {
    background: var(--primary-dark);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
}

.stop-btn {
    background: #EF4444;
    border: 1px solid #EF4444;
    color: white;
}

.stop-btn:hover {
    background: #DC2626;
    border-color: #DC2626;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
}

.clear-btn {
    padding: 0.5rem 1rem;
    border-radius: var(--radius-md);
    font-size: 0.875rem;
}

/* Recording Preview */
.recording-preview {
    background: var(--bg-main);
    border: 1px solid var(--border-light);
    border-radius: var(--radius-md);
    padding: 1.5rem;
    text-align: left;
}

.preview-header {
    margin-bottom: 1rem;
}

.preview-header h5 {
    font-size: 1.125rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.preview-header h5 i {
    color: var(--primary-main);
}

.preview-header p {
    color: var(--text-secondary);
    margin: 0;
    font-size: 0.875rem;
}

.recording-info {
    display: flex;
    justify-content: space-between;
    margin-top: 1rem;
    font-size: 0.875rem;
    color: var(--text-secondary);
}

/* Animations */
@keyframes pulse {
    0% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.5; transform: scale(1.2); }
    100% { opacity: 1; transform: scale(1); }
}

/* Toast Notifications */
.toast {
    animation: slideInRight 0.3s ease-out;
}

@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.toast-error {
    background: #EF4444 !important;
}

.toast-success {
    background: #10B981 !important;
}

.toast-info {
    background: #3B82F6 !important;
}

/* Responsive Design */
@media (max-width: 768px) {
    .form-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
    }
    
    .upload-area {
        padding: 2rem 1rem;
    }
    
    .upload-icon {
        font-size: 2rem;
    }
    
    .form-actions {
        flex-direction: column-reverse;
    }
    
    .form-actions .btn {
        width: 100%;
    }
    
    .processing-info {
        margin-left: 0;
    }
    
    .section-content {
        padding: 1rem;
    }
    
    .section-header {
        padding: 1rem;
    }
    
    /* Mobile recording adjustments */
    .toggle-buttons {
        flex-direction: column;
    }
    
    .record-container {
        padding: 1rem;
    }
    
    .record-status {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
    }
    
    .record-btn, .stop-btn {
        width: 100%;
        max-width: 250px;
    }
    
    .volume-meter {
        height: 40px;
    }
}

/* Form validation styles */
.was-validated .form-control:invalid,
.form-control.is-invalid {
    border-color: #DC3545;
    box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.1);
}

.was-validated .form-control:valid,
.form-control.is-valid {
    border-color: #198754;
    box-shadow: 0 0 0 3px rgba(25, 135, 84, 0.1);
}

.invalid-feedback {
    display: block;
    width: 100%;
    margin-top: 0.25rem;
    font-size: 0.875rem;
    color: #DC3545;
}


</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    initializeInputMethodToggle();
    initializeFileUpload();
    initializeRecording();
    initializeFormSubmission();
});

// Input Method Toggle
function initializeInputMethodToggle() {
    const uploadToggle = document.getElementById('uploadToggle');
    const recordToggle = document.getElementById('recordToggle');
    const uploadMethod = document.getElementById('uploadMethod');
    const recordMethod = document.getElementById('recordMethod');
    
    // Set Record Audio as default active tab
    recordToggle.classList.add('active');
    uploadToggle.classList.remove('active');
    recordMethod.classList.remove('d-none');
    uploadMethod.classList.add('d-none');
    
    uploadToggle.addEventListener('click', () => {
        uploadToggle.classList.add('active');
        recordToggle.classList.remove('active');
        uploadMethod.classList.remove('d-none');
        recordMethod.classList.add('d-none');
        
        // Clear any existing recording
        clearRecording();
    });
    
    recordToggle.addEventListener('click', () => {
        recordToggle.classList.add('active');
        uploadToggle.classList.remove('active');
        recordMethod.classList.remove('d-none');
        uploadMethod.classList.add('d-none');
        
        // Clear any existing file
        clearFileSelection();
    });
}

// File Upload Functions
function initializeFileUpload() {
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('audio_file');
    const filePreview = document.getElementById('filePreview');
    
    // Click to upload
    uploadArea.addEventListener('click', () => {
        fileInput.click();
    });
    
    // Drag and drop
    uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('dragover');
    });
    
    uploadArea.addEventListener('dragleave', () => {
        uploadArea.classList.remove('dragover');
    });
    
    uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            fileInput.files = files;
            handleFileSelection(files[0]);
        }
    });
    
    // File input change
    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
            handleFileSelection(e.target.files[0]);
        }
    });
}

function handleFileSelection(file) {
    const filePreview = document.getElementById('filePreview');
    const uploadArea = document.getElementById('uploadArea');
    
    // Validate file
    if (!validateAudioFile(file)) {
        return;
    }
    
    // Show file preview
    filePreview.innerHTML = `
        <div class="file-info">
            <i class="bi bi-music-note-beamed"></i>
            <div class="file-details">
                <div class="file-name">${file.name}</div>
                <div class="file-size">${formatFileSize(file.size)}</div>
                <div class="file-type">${file.type}</div>
            </div>
            <button type="button" class="btn btn-sm btn-outline-danger" onclick="clearFileSelection()">
                <i class="bi bi-trash"></i>
            </button>
        </div>
    `;
    
    filePreview.classList.remove('d-none');
    uploadArea.style.display = 'none';
}

function validateAudioFile(file) {
    const allowedTypes = [
        'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/flac', 
        'audio/mp4', 'audio/m4a', 'audio/aac', 'audio/ogg', 
        'audio/webm', 'audio/x-m4a'
    ];
    const maxSize = 50 * 1024 * 1024; // 50MB
    
    if (!allowedTypes.includes(file.type) && !file.name.match(/\.(mp3|wav|flac|m4a|aac|ogg|webm)$/i)) {
        showToast('Please select a valid audio file (MP3, WAV, FLAC, M4A, AAC, OGG, WEBM)', 'error');
        return false;
    }
    
    if (file.size > maxSize) {
        showToast('File size must be less than 50MB', 'error');
        return false;
    }
    
    return true;
}

function clearFileSelection() {
    const fileInput = document.getElementById('audio_file');
    const filePreview = document.getElementById('filePreview');
    const uploadArea = document.getElementById('uploadArea');
    
    fileInput.value = '';
    filePreview.classList.add('d-none');
    uploadArea.style.display = 'block';
}

// Recording Functions
let mediaRecorder = null;
let audioChunks = [];
let recordingStartTime = null;
let recordingTimer = null;
let audioContext = null;
let analyser = null;
let microphone = null;
let dataArray = null;
let recordings = []; // Array to store all recording segments
let currentRecording = null; // Current recording being worked on

function initializeRecording() {
    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const clearBtn = document.getElementById('clearBtn');
    const discardRecordingBtn = document.getElementById('discardRecordingBtn');
    const clearAllRecordingsBtn = document.getElementById('clearAllRecordingsBtn');
    
    recordBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', stopRecording);
    clearBtn.addEventListener('click', clearRecording);
    discardRecordingBtn.addEventListener('click', discardRecording);
    clearAllRecordingsBtn.addEventListener('click', clearAllRecordings);
    
    // Check if browser supports recording
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        recordBtn.disabled = true;
        recordBtn.innerHTML = '<i class="bi bi-exclamation-triangle"></i><span>Recording not supported</span>';
        showToast('Your browser does not support audio recording', 'error');
    }
}

async function startRecording() {
    try {
        // Request microphone access
        const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                sampleRate: 44100
            } 
        });
        
        // Initialize audio context for volume meter
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        microphone = audioContext.createMediaStreamSource(stream);
        
        analyser.fftSize = 256;
        const bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        
        microphone.connect(analyser);
        
        // Start recording
        mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'audio/webm;codecs=opus'
        });
        
        audioChunks = [];
        recordingStartTime = Date.now();
        
        mediaRecorder.addEventListener('dataavailable', (event) => {
            audioChunks.push(event.data);
        });
        
        mediaRecorder.addEventListener('stop', () => {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            handleRecordingComplete(audioBlob);
        });
        
        // Start recording and update UI
        mediaRecorder.start();
        updateRecordingUI(true);
        startVolumeMeter();
        startRecordingTimer();
        
        showToast('Recording started! Click stop when finished.', 'success');
        
    } catch (error) {
        console.error('Error starting recording:', error);
        showToast('Failed to start recording. Please check microphone permissions.', 'error');
    }
}

function stopRecording() {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        updateRecordingUI(false);
        stopVolumeMeter();
        stopRecordingTimer();
        
        // Stop all tracks to release microphone
        if (mediaRecorder.stream) {
            mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }
        
        showToast('Recording stopped!', 'success');
    }
}

function handleRecordingComplete(audioBlob) {
    const recordingPreview = document.getElementById('recordingPreview');
    const recordingAudio = document.getElementById('recordingAudio');
    const recordingDuration = document.getElementById('recordingDuration');
    const recordingSize = document.getElementById('recordingSize');
    
    // Create audio URL and set duration
    const audioUrl = URL.createObjectURL(audioBlob);
    recordingAudio.src = audioUrl;
    
    // Get recording duration
    const duration = (Date.now() - recordingStartTime) / 1000;
    recordingDuration.textContent = formatDuration(duration);
    
    // Get file size
    recordingSize.textContent = formatFileSize(audioBlob.size);
    
    // Store current recording
    currentRecording = {
        blob: audioBlob,
        duration: duration,
        size: audioBlob.size,
        url: audioUrl
    };
    
    // Show preview
    recordingPreview.classList.remove('d-none');
    
    // Auto-save the recording segment
    saveRecording();
    
    showToast('Recording segment auto-saved! You can continue recording more segments.', 'success');
}

function clearRecording() {
    const recordingPreview = document.getElementById('recordingPreview');
    const recordingAudio = document.getElementById('recordingAudio');
    
    // Clear preview
    recordingPreview.classList.add('d-none');
    recordingAudio.src = '';
    
    // Clear file input
    const fileInput = document.getElementById('audio_file');
    fileInput.value = '';
    
    // Reset recording state
    audioChunks = [];
    recordingStartTime = null;
    currentRecording = null;
    
    // Stop any ongoing recording
    if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        if (mediaRecorder.stream) {
            mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }
    }
    
    updateRecordingUI(false);
    stopVolumeMeter();
    stopRecordingTimer();
}

function saveRecording() {
    if (!currentRecording) {
        showToast('No recording to save!', 'error');
        return;
    }
    
    // Add recording to segments array
    const segment = {
        id: Date.now(),
        blob: currentRecording.blob,
        duration: currentRecording.duration,
        size: currentRecording.size,
        url: currentRecording.url
    };
    
    recordings.push(segment);
    
    // Update recordings table
    updateRecordingsTable();
    
    // Clear current recording
    clearRecording();
    
    showToast(`Recording segment saved! Total segments: ${recordings.length}`, 'success');
}

function discardRecording() {
    if (currentRecording) {
        // Find and remove the last saved recording (since it was auto-saved)
        if (recordings.length > 0) {
            const lastRecording = recordings.pop();
            URL.revokeObjectURL(lastRecording.url);
            updateRecordingsTable();
        }
        
        // Revoke the object URL to free memory
        URL.revokeObjectURL(currentRecording.url);
        currentRecording = null;
        clearRecording();
        showToast('Recording segment discarded and removed from list', 'info');
    }
}

function updateRecordingsTable() {
    const table = document.getElementById('recordingsTable');
    const tableBody = document.getElementById('recordingsTableBody');
    const totalSegments = document.getElementById('totalSegments');
    const totalDuration = document.getElementById('totalDuration');
    
    if (recordings.length === 0) {
        table.style.display = 'none';
        return;
    }
    
    table.style.display = 'block';
    totalSegments.textContent = recordings.length;
    
    // Calculate total duration
    const totalSeconds = recordings.reduce((sum, segment) => sum + segment.duration, 0);
    totalDuration.textContent = formatDuration(totalSeconds);
    
    // Clear existing rows
    tableBody.innerHTML = '';
    
    // Add each recording segment
    recordings.forEach((segment, index) => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${index + 1}</td>
            <td>${formatDuration(segment.duration)}</td>
            <td>${formatFileSize(segment.size)}</td>
            <td>
                <audio controls style="width: 200px; height: 40px;">
                    <source src="${segment.url}" type="audio/webm">
                </audio>
            </td>
            <td>
                <button type="button" class="btn btn-sm btn-outline-danger" onclick="deleteRecording(${segment.id})">
                    <i class="bi bi-trash"></i>
                </button>
            </td>
        `;
        tableBody.appendChild(row);
    });
    
    // Update form validation
    updateFormValidation();
}

function deleteRecording(segmentId) {
    const index = recordings.findIndex(segment => segment.id === segmentId);
    if (index !== -1) {
        // Revoke the object URL to free memory
        URL.revokeObjectURL(recordings[index].url);
        recordings.splice(index, 1);
        updateRecordingsTable();
        showToast('Recording segment deleted', 'info');
    }
}

function clearAllRecordings() {
    if (recordings.length === 0) {
        showToast('No recordings to clear', 'info');
        return;
    }
    
    if (confirm('Are you sure you want to delete all recording segments? This cannot be undone.')) {
        // Revoke all object URLs to free memory
        recordings.forEach(segment => URL.revokeObjectURL(segment.url));
        recordings = [];
        updateRecordingsTable();
        showToast('All recording segments cleared', 'info');
    }
}

function updateFormValidation() {
    const fileInput = document.getElementById('audio_file');
    const hasFile = fileInput.files && fileInput.files.length > 0;
    const hasRecordings = recordings.length > 0;
    
    // Form is valid if either file is uploaded or recordings exist
    const isValid = hasFile || hasRecordings;
    
    // Update the hidden input with recordings data
    const recordingsData = document.getElementById('recordings_data');
    recordingsData.value = JSON.stringify(recordings.map(segment => ({
        id: segment.id,
        duration: segment.duration,
        size: segment.size
    })));
    
    // Update submit button state if needed
    const submitBtn = document.getElementById('submitBtn');
    if (submitBtn) {
        submitBtn.disabled = !isValid;
    }
}

function updateRecordingUI(isRecording) {
    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const clearBtn = document.getElementById('clearBtn');
    const statusIndicator = document.querySelector('.status-indicator');
    const recordTime = document.getElementById('recordTime');
    
    if (isRecording) {
        recordBtn.classList.add('d-none');
        stopBtn.classList.remove('d-none');
        clearBtn.classList.remove('d-none');
        statusIndicator.classList.add('recording');
        statusIndicator.innerHTML = '<i class="bi bi-mic"></i><span>Recording...</span>';
        recordTime.textContent = '00:00';
    } else {
        recordBtn.classList.remove('d-none');
        stopBtn.classList.add('d-none');
        clearBtn.classList.add('d-none');
        statusIndicator.classList.remove('recording');
        statusIndicator.innerHTML = '<i class="bi bi-mic"></i><span>Ready to record</span>';
        recordTime.textContent = '00:00';
    }
}

function startVolumeMeter() {
    if (!analyser) return;
    
    function updateVolume() {
        if (analyser && dataArray) {
            analyser.getByteFrequencyData(dataArray);
            
            // Calculate average volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const average = sum / dataArray.length;
            
            // Update volume bar (0-100%)
            const volumeBar = document.getElementById('volumeBar');
            if (volumeBar) {
                volumeBar.style.width = Math.min(average * 2, 100) + '%';
            }
        }
        
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            requestAnimationFrame(updateVolume);
        }
    }
    
    updateVolume();
}

function stopVolumeMeter() {
    const volumeBar = document.getElementById('volumeBar');
    if (volumeBar) {
        volumeBar.style.width = '0%';
    }
}

function startRecordingTimer() {
    recordingStartTime = Date.now();
    recordingTimer = setInterval(() => {
        const elapsed = Date.now() - recordingStartTime;
        const seconds = Math.floor(elapsed / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        
        const recordTime = document.getElementById('recordTime');
        if (recordTime) {
            recordTime.textContent = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
    }, 1000);
}

function stopRecordingTimer() {
    if (recordingTimer) {
        clearInterval(recordingTimer);
        recordingTimer = null;
    }
}

function formatDuration(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

// Form Submission
function initializeFormSubmission() {
    const form = document.getElementById('createPostForm');
    const submitBtn = document.getElementById('submitBtn');
    
    // Check which API provider is available
    checkApiProvider();
    
    form.addEventListener('submit', function(e) {
        // Validate that we have either a file or recordings
        const fileInput = document.getElementById('audio_file');
        const hasFile = fileInput.files && fileInput.files.length > 0;
        const hasRecordings = recordings.length > 0;
        
        if (!hasFile && !hasRecordings) {
            e.preventDefault();
            showToast('Please provide an audio file or record audio before creating a post.', 'error');
            return;
        }
        
        // If we have recordings, we need to combine them first
        if (hasRecordings) {
            e.preventDefault();
            combineRecordingsAndSubmit();
            return;
        }
        
        // If auto-process is enabled, show message about redirecting to processing page
        const autoProcess = document.getElementById('auto_process').checked;
        if (autoProcess) {
            showToast('Redirecting to processing page...', 'info');
        }
        
        // Add form submission debugging
        console.log('Form submitted with data:', {
            title: document.getElementById('title').value,
            privacy_level: document.getElementById('privacy_level').value,
            auto_process: autoProcess,
            audio_file: document.getElementById('audio_file').files[0]?.name || 'None'
        });
    });
    
    // Check database health on page load
    checkDatabaseHealth();
}

async function combineRecordingsAndSubmit() {
    const submitBtn = document.getElementById('submitBtn');
    
    try {
        // Disable button during processing
        submitBtn.disabled = true;
        
        showToast('Combining recording segments...', 'info');
        
        // Create a combined audio blob
        const combinedBlob = await combineAudioBlobs(recordings.map(r => r.blob));
        
        // Convert to file and set in form
        const combinedFile = new File([combinedBlob], 'combined_recording.webm', { type: 'audio/webm' });
        const fileInput = document.getElementById('audio_file');
        const dataTransfer = new DataTransfer();
        dataTransfer.items.add(combinedFile);
        fileInput.files = dataTransfer.files;
        
        // Clear recordings array to free memory
        recordings.forEach(segment => URL.revokeObjectURL(segment.url));
        recordings = [];
        
        showToast('Recordings combined successfully! Submitting form...', 'success');
        
        // Submit the form
        setTimeout(() => {
            document.getElementById('createPostForm').submit();
        }, 1000);
        
    } catch (error) {
        console.error('Error combining recordings:', error);
        showToast('Failed to combine recordings. Please try again.', 'error');
        
        // Reset button state
        submitBtn.disabled = false;
    }
}

async function combineAudioBlobs(blobs) {
    // For now, we'll use a simple concatenation approach
    // In a production environment, you'd want to use Web Audio API or send to backend for ffmpeg processing
    
    // Create a new blob from all the recording blobs
    const combinedBlob = new Blob(blobs, { type: 'audio/webm' });
    
    // Note: This is a basic concatenation. For proper audio merging with ffmpeg,
    // you would need to send the recordings to your backend and process them there.
    
    return combinedBlob;
}

function checkDatabaseHealth() {
    fetch('/api/db-health')
        .then(response => response.json())
        .then(data => {
            console.log('Database health check:', data);
            if (data.status === 'unhealthy') {
                showToast('Database health check failed. Check console for details.', 'error');
            }
        })
        .catch(error => {
            console.error('Database health check failed:', error);
            showToast('Database health check failed. Check console for details.', 'error');
        });
}

function checkApiProvider() {
    // Check which API provider is available
    fetch('/api/ai-provider')
        .then(response => response.json())
        .then(data => {
            const apiProvider = document.getElementById('apiProvider');
            if (apiProvider && data.provider) {
                apiProvider.textContent = data.name;
                
                // Update the processing info with provider-specific details
                updateProcessingInfo(data);
            } else if (apiProvider) {
                apiProvider.textContent = 'None (Manual processing only)';
                showApiWarning();
            }
        })
        .catch(error => {
            console.error('Error checking API provider:', error);
            const apiProvider = document.getElementById('apiProvider');
            if (apiProvider) {
                apiProvider.textContent = 'Unknown';
            }
        });
}

function updateProcessingInfo(providerData) {
    // Update processing info based on the provider
    const processingInfo = document.querySelector('.processing-info');
    if (processingInfo && providerData.provider) {
        const firstInfoItem = processingInfo.querySelector('.info-item:first-child');
        if (firstInfoItem) {
            const icon = firstInfoItem.querySelector('i');
            const text = firstInfoItem.querySelector('span');
            
            if (providerData.provider === 'gemini') {
                icon.className = 'bi bi-google';
                text.innerHTML = `Transcript generation using <strong>${providerData.name}</strong>`;
            } else if (providerData.provider === 'openai') {
                icon.className = 'bi bi-openai';
                text.innerHTML = `Transcript generation using <strong>${providerData.name}</strong>`;
            }
        }
    }
}

function showApiWarning() {
    // Show warning if no API is configured
    const alertDiv = document.querySelector('.alert-info');
    if (alertDiv) {
        alertDiv.className = 'alert alert-warning';
        alertDiv.innerHTML = `
            <i class="bi bi-exclamation-triangle"></i>
            <strong>Warning:</strong> No AI API key configured. You can still create posts, but transcription and summary generation will not be available.
            <br><small>Configure either OPENAI_API_KEY or GEMINI_API_KEY in your environment variables.</small>
        `;
    }
}

// Utility Functions
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function showToast(message, type = 'info') {
    // Simple toast implementation if VoiceLog.showToast is not available
    if (typeof VoiceLog !== 'undefined' && VoiceLog.showToast) {
        VoiceLog.showToast(message, type);
    } else {
        // Fallback toast
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${type === 'error' ? '#EF4444' : type === 'success' ? '#10B981' : '#3B82F6'};
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 9999;
            max-width: 300px;
            word-wrap: break-word;
        `;
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.remove();
        }, 5000);
    }
}
</script>
{% endblock %}